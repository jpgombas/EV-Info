import SwiftUI
import CoreBluetooth
import Combine

// MARK: - Debug Log Level
enum LogLevel: String, CaseIterable {
    case verbose = "ðŸ”"
    case info = "â„¹ï¸"
    case success = "âœ…"
    case warning = "âš ï¸"
    case error = "âŒ"
    case data = "ðŸ“Š"
}

// MARK: - BLE Manager
class BLEManager: NSObject, ObservableObject {
    private var centralManager: CBCentralManager!
    private var peripheral: CBPeripheral?
    private var writeCharacteristic: CBCharacteristic?
    private var notifyCharacteristic: CBCharacteristic?
    
    // Data fetching state
    private var dataTimer: Timer?
    private var currentCommandIndex = 0
    private var isWaitingForResponse = false
    private var responseBuffer = ""
    
    // Device configuration
    private let targetDeviceName = "VEEPEAK"
    private var targetDeviceUUID: UUID?
    
    // OBD2 BLE service UUIDs
    private let obd2ServiceUUIDs = [
        CBUUID(string: "FFF0"),
        CBUUID(string: "18F0"),
        CBUUID(string: "FFE0"),
    ]
    
    private let writeCharacteristicUUID = CBUUID(string: "FFE1")
    private let notifyCharacteristicUUID = CBUUID(string: "FFE1")
    
    // Published properties for UI
    @Published var isConnected = false
    @Published var isScanning = false
    @Published var vehicleSpeed: Double = 0
    @Published var batteryCurrent: Double = 0.0
    @Published var vehicleVoltage: Double = 0.0
    @Published var vehiclePower: Double = 0.0
    @Published var vehicleEff: Double = 0.0
    @Published var vehicleStateOfCharge: Double = 0.0
    @Published var debugMessages: [(id: UUID, message: String)] = []
    @Published var connectionStatus = "Disconnected"
    @Published var logLevel: LogLevel = .info
    
    // Commands
    private let initCommands = ["ATZ", "ATD", "ATE0", "ATS0", "ATAL", "ATSP6"]
    private let fetchCommands = ["010D", "222414", "222885", "228334"]
    
    // Init state tracking
    private var initCommandIndex = 0
    private var isInitializing = false
    private var initResponseTimer: Timer?
    
    override init() {
        super.init()
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.centralManager = CBCentralManager(delegate: self, queue: nil)
            self.log(.info, "BLE Manager initialized")
        }
    }
    
    // MARK: - Consolidated Logging
    private func log(_ level: LogLevel, _ message: String, forceShow: Bool = false) {
        // Only show logs at or above current log level, unless forced
        let shouldShow = forceShow ||
                        (level == .error) ||
                        (level == .warning) ||
                        (logLevel == .verbose) ||
                        (logLevel == .info && level != .verbose) ||
                        (logLevel == .data && level == .data)
        
        guard shouldShow else { return }
        
        DispatchQueue.main.async {
            let timestamp = DateFormatter.localizedString(from: Date(), dateStyle: .none, timeStyle: .medium)
            let fullMessage = "[\(timestamp)] \(level.rawValue) \(message)"
            self.debugMessages.append((id: UUID(), message: fullMessage))
            
            // Keep only last 30 messages for better performance
            if self.debugMessages.count > 30 {
                self.debugMessages.removeFirst()
            }
        }
    }
    
    func startScanning() {
        let state = centralManager.state
        log(.verbose, "BLE state: \(state.rawValue)")
        
        switch state {
        case .poweredOn:
            isScanning = true
            connectionStatus = "Scanning..."
            log(.info, "Started scanning for OBD2 devices")
            centralManager.scanForPeripherals(withServices: nil, options: nil)
        case .poweredOff:
            connectionStatus = "Bluetooth Off"
            log(.error, "Bluetooth is powered off")
        case .unauthorized:
            connectionStatus = "Bluetooth Unauthorized"
            log(.error, "Bluetooth access denied")
        default:
            connectionStatus = "Bluetooth Issue"
            log(.warning, "Bluetooth state: \(state)")
        }
    }
    
    func stopScanning() {
        centralManager.stopScan()
        isScanning = false
        log(.info, "Stopped scanning")
        if !isConnected {
            connectionStatus = "Scan stopped"
        }
    }
    
    func disconnect() {
        guard let peripheral = peripheral else { return }
        
        // Clean up timers and state
        [dataTimer, initResponseTimer].forEach { $0?.invalidate() }
        dataTimer = nil
        initResponseTimer = nil
        isWaitingForResponse = false
        isInitializing = false
        
        centralManager.cancelPeripheralConnection(peripheral)
        log(.info, "Disconnecting from device")
    }
    
    func checkBluetoothStatus() {
        let stateDesc = getBluetoothStateDescription()
        log(.info, "=== Bluetooth Status ===", forceShow: true)
        log(.info, "State: \(stateDesc)", forceShow: true)
        log(.info, "Target: \(targetDeviceName)", forceShow: true)
        log(.info, "Connected: \(isConnected)", forceShow: true)
        log(.info, "Scanning: \(isScanning)", forceShow: true)
        if let peripheral = peripheral {
            log(.info, "Device: \(peripheral.name ?? "Unknown")", forceShow: true)
        }
        log(.info, "=== End Status ===", forceShow: true)
    }
    
    private func getBluetoothStateDescription() -> String {
        switch centralManager?.state {
        case .unknown: return "Unknown"
        case .resetting: return "Resetting"
        case .unsupported: return "Unsupported"
        case .unauthorized: return "Unauthorized"
        case .poweredOff: return "Powered Off"
        case .poweredOn: return "Powered On"
        case .none: return "Manager nil"
        @unknown default: return "Unknown state"
        }
    }
    
    private func sendInitCommands() {
        log(.info, "Starting OBD2 initialization (\(initCommands.count) commands)")
        initCommandIndex = 0
        isInitializing = true
        sendNextInitCommand()
    }
    
    private func sendNextInitCommand() {
        guard let writeChar = writeCharacteristic,
              initCommandIndex < initCommands.count,
              isInitializing else { return }
        
        let command = initCommands[initCommandIndex]
        log(.verbose, "Init (\(initCommandIndex + 1)/\(initCommands.count)): \(command)")
        
        let data = (command + "\r").data(using: .utf8)!
        peripheral?.writeValue(data, for: writeChar, type: .withResponse)
        
        // Timeout for init command
        initResponseTimer?.invalidate()
        initResponseTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: false) { [weak self] _ in
            self?.log(.warning, "Init timeout: \(command)")
            self?.continueInitSequence()
        }
    }
    
    private func continueInitSequence() {
        initResponseTimer?.invalidate()
        initCommandIndex += 1
        
        if initCommandIndex >= initCommands.count {
            isInitializing = false
            log(.success, "Initialization complete - starting data fetch")
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                self.startDataFetching()
            }
        } else {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.sendNextInitCommand()
            }
        }
    }
    
    private func startDataFetching() {
        log(.info, "Starting periodic data fetching")
        
        dataTimer?.invalidate()
        currentCommandIndex = 0
        isWaitingForResponse = false
        
        dataTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in
            guard let self = self, self.isConnected, let writeChar = self.writeCharacteristic else {
                self?.log(.warning, "Data timer stopped - not connected")
                timer.invalidate()
                return
            }
            
            if self.isWaitingForResponse {
                self.log(.verbose, "Skipping cycle - waiting for response")
                return
            }
            
            let command = self.fetchCommands[self.currentCommandIndex]
            let data = (command + "\r").data(using: .utf8)!
            
            self.log(.verbose, "Sending: \(command)")
            self.peripheral?.writeValue(data, for: writeChar, type: .withResponse)
            self.isWaitingForResponse = true
            
            self.currentCommandIndex = (self.currentCommandIndex + 1) % self.fetchCommands.count
            
            // Response timeout
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                if self.isWaitingForResponse {
                    self.log(.warning, "Response timeout: \(command)")
                    self.isWaitingForResponse = false
                }
            }
        }
    }
    
    private func parseNotificationData(_ data: Data) {
        // Only log data details in verbose mode
        if logLevel == .verbose {
            log(.data, "Raw: \(data.map { String(format: "%02X", $0) }.joined(separator: " "))")
        }
        
        guard let chunk = String(data: data, encoding: .utf8) else {
            log(.error, "Could not decode data")
            return
        }
        
        let text = chunk.trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Handle init responses
        if isInitializing {
            responseBuffer.append(chunk)
            if responseBuffer.contains(">") {
                log(.verbose, "Init response: \(responseBuffer.trimmingCharacters(in: .whitespacesAndNewlines))")
                continueInitSequence()
                responseBuffer = ""
            }
            return
        }
        
        isWaitingForResponse = false
        
        guard !text.isEmpty else {
            log(.verbose, "Empty response")
            return
        }
        
        // Parse different response types
        parseOBD2Response(text)
    }
    
    private func parseOBD2Response(_ text: String) {
        let cleanText = text.replacingOccurrences(of: " ", with: "")
                           .replacingOccurrences(of: "\r", with: "")
                           .replacingOccurrences(of: "\n", with: "")
        
        // Vehicle Speed (PID 010D)
        if cleanText.contains("410D") {
            if let range = cleanText.range(of: "410D"),
               String(cleanText[range.upperBound...]).count >= 2 {
                let speedHex = String(cleanText[range.upperBound...].prefix(2))
                if let speedValue = Int(speedHex, radix: 16) {
                    let speedMph = Double(speedValue) * 0.62
                    DispatchQueue.main.async {
                        self.vehicleSpeed = speedMph
                        self.updateEfficiency()
                    }
                    log(.data, "Speed: \(Int(speedMph)) mph")
                }
            }
        }
        // Battery Current (PID 622414)
        else if cleanText.contains("622414") {
            parseBatteryCurrent(cleanText)
        }
        // Voltage (PID 622885)
        else if cleanText.contains("622885") {
            parseVoltage(cleanText)
        }
        // State of Charge (PID 628334)
        else if cleanText.contains("628334") {
            parseStateOfCharge(cleanText)
        }
        // Other responses
        else {
            if text.contains("OK") {
                log(.verbose, "Command OK")
            } else if text.contains("?") || text.contains("ERROR") {
                log(.warning, "Command error: \(text)")
            } else {
                log(.verbose, "Other: \(text)")
            }
        }
    }
    
    private func parseBatteryCurrent(_ cleanText: String) {
        guard let range = cleanText.range(of: "622414") else { return }
        let afterPattern = String(cleanText[range.upperBound...])
        
        let hexParts = extractHexParts(from: afterPattern)
        guard hexParts.count >= 2,
              let A = Int(hexParts[0], radix: 16),
              let B = Int(hexParts[1], radix: 16) else {
            log(.warning, "Failed to parse current")
            return
        }
        
        let signedA = A < 128 ? A : A - 256
        let current = Double(signedA * 256 + B) / 20.0
        
        DispatchQueue.main.async {
            self.batteryCurrent = current
            self.updatePowerAndEfficiency()
        }
        log(.data, "Current: \(String(format: "%.1f", current)) A")
    }
    
    private func parseVoltage(_ cleanText: String) {
        guard let range = cleanText.range(of: "622885") else { return }
        let afterPattern = String(cleanText[range.upperBound...])
        
        let hexParts = extractHexParts(from: afterPattern)
        guard hexParts.count >= 2,
              let A = Int(hexParts[0], radix: 16),
              let B = Int(hexParts[1], radix: 16) else {
            log(.warning, "Failed to parse voltage")
            return
        }
        
        let voltage = Double(A * 256 + B) / 100.0
        DispatchQueue.main.async {
            self.vehicleVoltage = voltage
            self.updatePowerAndEfficiency()
        }
        log(.data, "Voltage: \(String(format: "%.1f", voltage)) V")
    }
    
    private func parseStateOfCharge(_ cleanText: String) {
        guard let range = cleanText.range(of: "628334") else { return }
        let afterPattern = String(cleanText[range.upperBound...])
        
        let hexParts = extractHexParts(from: afterPattern)
        guard hexParts.count >= 1,
              let A = Int(hexParts[0], radix: 16) else {
            log(.warning, "Failed to parse SoC")
            return
        }
        
        let soc = Double(A) * 100.0 / 255.0
        DispatchQueue.main.async {
            self.vehicleStateOfCharge = soc
        }
        log(.data, "SoC: \(String(format: "%.1f", soc))%")
    }
    
    private func extractHexParts(from text: String) -> [String] {
        var hexParts: [String] = []
        for i in stride(from: 0, to: text.count, by: 2) {
            let start = text.index(text.startIndex, offsetBy: i)
            guard text.distance(from: start, to: text.endIndex) >= 2 else { break }
            let end = text.index(start, offsetBy: 2)
            hexParts.append(String(text[start..<end]))
        }
        return hexParts
    }
    
    private func updatePowerAndEfficiency() {
        vehiclePower = batteryCurrent * vehicleVoltage / 1000.0
        updateEfficiency()
    }
    
    private func updateEfficiency() {
        let eff = vehicleSpeed / vehiclePower
        vehicleEff = (eff < 0 || eff > 20) ? -1 : abs(eff)
    }
}

// MARK: - CBCentralManagerDelegate
extension BLEManager: CBCentralManagerDelegate {
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        let stateDesc = getBluetoothStateDescription()
        connectionStatus = stateDesc == "Powered On" ? "Ready to connect" : stateDesc
        log(.info, "Bluetooth: \(stateDesc)")
    }
    
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
        let deviceName = peripheral.name ?? "Unknown Device"
        
        // Only log relevant devices
        if deviceName != "Unknown Device" || RSSI.intValue > -70 {
            log(.verbose, "Discovered: \(deviceName) (\(RSSI) dBm)")
        }
        
        // Check for OBD2 device
        let isOBD2Device = deviceName.uppercased().contains(targetDeviceName.uppercased()) ||
                          deviceName.uppercased().contains("OBD") ||
                          deviceName.uppercased().contains("ELM")
        
        if isOBD2Device {
            log(.success, "Found OBD2 device: \(deviceName)")
            self.targetDeviceUUID = peripheral.identifier
            self.peripheral = peripheral
            peripheral.delegate = self
            centralManager.connect(peripheral, options: nil)
            stopScanning()
        }
    }
    
    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        log(.success, "Connected to \(peripheral.name ?? "device")")
        connectionStatus = "Connected - Discovering services..."
        isConnected = true
        peripheral.discoverServices(nil)
    }
    
    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
        log(.error, "Connection failed: \(error?.localizedDescription ?? "Unknown")")
        connectionStatus = "Connection failed"
    }
    
    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        log(.info, "Disconnected")
        isConnected = false
        connectionStatus = "Disconnected"
        self.peripheral = nil
        writeCharacteristic = nil
        notifyCharacteristic = nil
    }
}

// MARK: - CBPeripheralDelegate
extension BLEManager: CBPeripheralDelegate {
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        guard let services = peripheral.services else { return }
        
        log(.verbose, "Found \(services.count) services")
        for service in services {
            peripheral.discoverCharacteristics(nil, for: service)
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        guard let characteristics = service.characteristics else { return }

        for characteristic in characteristics {
            log(.verbose, "Characteristic: \(characteristic.uuid.uuidString)")

            // Find notify characteristic
            if notifyCharacteristic == nil && characteristic.properties.contains(.notify) {
                notifyCharacteristic = characteristic
                peripheral.setNotifyValue(true, for: characteristic)
                log(.success, "Notify characteristic set")
            }

            // Find write characteristic
            if writeCharacteristic == nil &&
               (characteristic.properties.contains(.write) || characteristic.properties.contains(.writeWithoutResponse)) {
                writeCharacteristic = characteristic
                log(.success, "Write characteristic set")
            }
        }

        // Start init if both characteristics found
        if writeCharacteristic != nil && notifyCharacteristic != nil {
            connectionStatus = "Connected - Ready"
            sendInitCommands()
        }
    }
    
    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        guard let data = characteristic.value else { return }
        parseNotificationData(data)
    }
    
    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
        let status = characteristic.isNotifying ? "enabled" : "disabled"
        log(.verbose, "Notifications \(status)")
    }
}

// MARK: - SwiftUI Views
struct ContentView: View {
    @StateObject private var bleManager = BLEManager()
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Connection Status
                Text(bleManager.connectionStatus)
                    .foregroundColor(bleManager.isConnected ? .green : .red)
                    .font(.subheadline)
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(10)
                
                // Vehicle Data Display
                HStack(spacing: 30) {
                    // Vehicle Speed
                    VStack {
                        Text("Vehicle Speed")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text("\(Int(bleManager.vehicleSpeed))")
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("mph")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                    
                    // Battery Current
                    VStack {
                        Text("Battery Current")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text(String(format: "%.1f", bleManager.batteryCurrent))
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("A")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                }
                
                HStack(spacing: 30) {
                    // Voltage
                    VStack {
                        Text("Voltage")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text("\(bleManager.vehicleVoltage, specifier: "%.1f")")
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("V")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                    
                    // Power
                    VStack {
                        Text("Power")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text("\(bleManager.vehiclePower, specifier: "%.1f")")
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("kW")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                }
                
                HStack(spacing: 30) {
                    VStack {
                        Text("Battery Level")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text("\(bleManager.vehicleStateOfCharge, specifier: "%.1f")")
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("%")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                
                    // Efficiency
                    VStack {
                        Text("Efficiency")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        HStack(alignment: .bottom, spacing: 5) {
                            Text("\(bleManager.vehicleEff, specifier: "%.1f")")
                                .font(.system(size: 30, weight: .bold, design: .monospaced))
                            Text("mi/kWh")
                                .font(.footnote)
                                .foregroundColor(.secondary)
                                .padding(.bottom, 8)
                        }
                    }
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(15)
                }
                
                // Connection Buttons
                VStack(spacing: 15) {
                    HStack(spacing: 20) {
                        Button(action: {
                            if bleManager.isScanning {
                                bleManager.stopScanning()
                            } else {
                                bleManager.startScanning()
                            }
                        }) {
                            Text(bleManager.isScanning ? "Stop Scan" : "Connect")
                                .frame(width: 120)
                        }
                        .buttonStyle(.borderedProminent)
                        .disabled(bleManager.isConnected)
                        
                        Button(action: {
                            bleManager.disconnect()
                        }) {
                            Text("Disconnect")
                                .frame(width: 120)
                        }
                        .buttonStyle(.bordered)
                        .disabled(!bleManager.isConnected)
                    }
                    
                    // Debug controls
                    HStack {
                        Button("Check Status") {
                            bleManager.checkBluetoothStatus()
                        }
                        .buttonStyle(.bordered)
                        .font(.caption)
                        
                        // Log level picker
                        Picker("Log Level", selection: $bleManager.logLevel) {
                            ForEach(LogLevel.allCases, id: \.self) { level in
                                Text(level.rawValue).tag(level)
                            }
                        }
                        .pickerStyle(MenuPickerStyle())
                        .font(.caption)
                    }
                }
                
                Spacer()
                
                // Consolidated Debug Information
                VStack(alignment: .leading, spacing: 5) {
                    HStack {
                        Text("Debug Log")
                            .font(.headline)
                        Spacer()
                        Text("Level: \(bleManager.logLevel.rawValue)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.bottom, 5)
                    
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: 2) {
                            ForEach(bleManager.debugMessages.reversed(), id: \.id) { item in
                                Text(item.message)
                                    .font(.system(.caption, design: .monospaced))
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    .frame(maxHeight: 200)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
            }
            .padding()
        }
    }
}

#Preview {
    ContentView()
}
